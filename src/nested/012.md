# **Module 12: Graph Databases for Soil Food Web Networks**

Model trophic interactions, mycorrhizal networks, and metabolic pathways using Neo4j or similar platforms. Implement efficient queries for pathway analysis and community assembly rules.

The course objective is to model the intricate web of biological and chemical relationships within the soil ecosystem using graph databases. Students will master the design of graph schemas and the implementation of efficient Cypher queries to analyze trophic interactions, mycorrhizal networks, and metabolic pathways. The goal is to transform disparate biological data into a unified, queryable knowledge graph that can reveal emergent properties of the soil system.

This module represents a conceptual leap in the **Foundation Phase**. While previous modules focused on generating and cleaning tabular or spatial data, this module is about modeling the *connections between* data points. It directly utilizes the outputs of the metagenomics pipeline (Module 5) to build a relational data structure that is essential for foundation models like **RhizosphereNet**, **MycorrhizalMapper**, and **SyntrophicNetworks**. This is where we move from a parts list of the soil ecosystem to a circuit diagram of how it functions.

---

### **Hour 1-2: Why Relational Databases Fail for Relationships** ü§î

**Learning Objectives:**
* Understand the limitations of the relational (SQL) model for querying highly connected data.
* Grasp the core concepts of the Labeled Property Graph (LPG) model: Nodes, Relationships, and Properties.
* Set up a local Neo4j graph database and become familiar with the interactive browser.

**Content:**
* **The `JOIN` Nightmare**: We'll start with a simple question: "Find all microbes that produce an enzyme that is part of a pathway that breaks down a compound that is excreted by another microbe." In SQL, this is a series of complex, slow, and brittle `JOIN`s. In a graph, it's a simple path.
* **The Graph Paradigm Shift**: Thinking in terms of entities and the connections between them.
    * **Nodes**: The "nouns" of your system (e.g., `Microbe`, `Gene`, `Compound`).
    * **Relationships**: The "verbs" that connect them (e.g., `ENCODES`, `CATALYZES`, `CONSUMES`).
    * **Properties**: The key-value attributes of nodes and relationships (e.g., `name: 'Pseudomonas'`, `rate: 2.5`).
* **Introduction to Neo4j**: The leading graph database platform. We will use Docker to launch a Neo4j instance and explore the Neo4j Browser, a powerful tool for interactive querying and visualization.

**Practical Exercise: Your First Graph**
* In the Neo4j Browser, manually create a small, visual graph.
* Create nodes with labels `:Bacterium`, `:Fungus`, `:Nematode`, and `:OrganicMatter`.
* Create relationships between them like `(n:Nematode)-[:EATS]->(b:Bacterium)` and `(f:Fungus)-[:DECOMPOSES]->(om:OrganicMatter)`.
* This hands-on, visual task builds immediate intuition for the graph model.

---

### **Hour 3-4: The Cypher Query Language: Drawing Your Questions** ‚úçÔ∏è

**Learning Objectives:**
* Learn the basic syntax and clauses of Cypher, Neo4j's declarative query language.
* Write queries to create, read, update, and delete data (CRUD).
* Master the art of pattern matching to ask complex questions of the graph.

**Content:**
* **Declarative & Visual**: Cypher is designed to look like "ASCII art." The pattern you draw is the pattern the database finds.
* **Core Clauses**:
    * `CREATE`: Create nodes and relationships.
    * `MATCH`: The workhorse for finding patterns in the data.
    * `WHERE`: Filtering results based on property values.
    * `RETURN`: Specifying what data to return.
    * `MERGE`: A combination of `MATCH` and `CREATE` to find a node or create it if it doesn't exist (critical for data ingestion).
* **The Pattern is Everything**: A deep dive into the `(node)-[:RELATIONSHIP]->(node)` syntax.

**Hands-on Lab:**
* Write a Cypher script to programmatically create the food web from the previous lab.
* Write a series of `MATCH` queries to answer questions like:
    * "Find all organisms that eat Bacteria."
    * "What does the Fungus decompose?"
    * "Return the entire graph." (And see how Neo4j visualizes it).

---

### **Hour 5-6: Ingesting Metagenomic Data into a Knowledge Graph** üß¨

**Learning Objectives:**
* Design a graph schema to represent the outputs of the metagenomics pipeline (Module 5).
* Use the `LOAD CSV` command to efficiently bulk-load data into Neo4j.
* Build the foundational layer of a soil bioinformatics knowledge graph.

**Content:**
* **From Tables to Graph**: We will design a schema to convert the tabular outputs (MAGs, gene annotations, pathway summaries) from Module 5 into a connected graph.
* **The Schema**:
    * **Nodes**: `:MAG` (Metagenome-Assembled Genome), `:Contig`, `:Gene`, `:Pathway`, `:Enzyme`.
    * **Relationships**: `(:MAG)-[:CONTAINS]->(:Contig)`, `(:Contig)-[:HAS_GENE]->(:Gene)`, `(:Gene)-[:CODES_FOR]->(:Enzyme)`, `(:Enzyme)-[:PARTICIPATES_IN]->(:Pathway)`.
* **`LOAD CSV`**: Neo4j's powerful, declarative command for high-speed data ingestion. We'll cover best practices for preparing CSV files and writing idempotent ingestion scripts using `MERGE`.

**Engineering Sprint:**
* Take the final MAG quality table and the gene annotation table produced in the Module 5 capstone project.
* Write a single, well-documented Cypher script that uses `LOAD CSV` to:
    1.  Create a unique node for each MAG.
    2.  Create a unique node for each gene.
    3.  Create a unique node for each metabolic pathway.
    4.  Create all the relationships connecting them.
* Verify the ingestion by running queries to count the different node and relationship types.

---

### **Hour 7-8: Modeling Soil Food Webs & Trophic Levels** üï∏Ô∏è

**Learning Objectives:**
* Extend the graph schema to include higher trophic levels (protists, nematodes, fungi).
* Add properties to relationships to capture the strength or type of interaction.
* Write queries that traverse the food web to determine trophic position and food chain length.

**Content:**
* **Expanding the Ecosystem**: Adding nodes for `:Protist` and `:Nematode` and relationships for `:CONSUMES`.
* **Rich Relationships**: We can add properties to relationships to make them more descriptive, e.g., `(n:Nematode)-[:CONSUMES {preference: 0.9, method: 'piercing'}]->(f:Fungus)`.
* **Food Web Queries**:
    * **Direct Interactions**: "Which nematodes consume *Pseudomonas*?"
    * **Variable-Length Paths**: "Find all food chains up to 4 steps long starting from Cellulose." `MATCH p = (:Cellulose)<-[:DECOMPOSES|EATS*1..4]-(predator) RETURN p`.
    * **Trophic Level**: Calculating a node's position in the food web.

**Practical Exercise:**
* Augment your existing graph by using `LOAD CSV` to import a list of known predator-prey interactions.
* Write a Cypher query to find the longest food chain in your dataset.
* Write a query to identify "omnivores": organisms that consume others at more than one trophic level.

---

### **Hour 9-10: Modeling Metabolic Pathways & Mycorrhizal Networks** üçÑ

**Learning Objectives:**
* Model a biochemical pathway as a graph of compounds, reactions, and enzymes.
* Query the graph to perform pathway analysis, such as checking for completeness.
* Design a schema for the symbiotic exchange of nutrients in a mycorrhizal network.

**Content:**
* **Metabolic Pathways as Graphs**: This is the most natural way to represent metabolism.
    * **Schema**: `(:Compound)-[:IS_SUBSTRATE_FOR]->(:Reaction)`, `(:Reaction)-[:PRODUCES]->(:Compound)`, `(:Enzyme)-[:CATALYZES]->(:Reaction)`.
* **Powerful Pathway Queries**:
    * "Find the shortest biochemical path from Nitrate to N2 gas (denitrification)."
    * "Given this MAG, does it possess all the enzymes necessary to complete this pathway?"
* **Mycorrhizal Networks**: Modeling the "fungal highway."
    * **Schema**: `(:Plant {species: 'Corn'})-[:FORMS_SYMBIOSIS_WITH]->(:Fungus {species: 'G. intraradices'})`.
    * **Exchange Relationships**: `(f:Fungus)-[:TRANSPORTS {compound: 'Phosphate'}]->(p:Plant)`.

**Pathway Analysis Lab:**
* Import a subsection of the KEGG pathway database for nitrogen cycling.
* Write a Cypher query that accepts a `mag_id` as a parameter.
* The query must traverse the graph to determine if that MAG has a complete set of enzymes to perform the denitrification pathway and return `true` or `false`.

---

### **Hour 11-12: Graph Algorithms for Ecological Insight** üß†

**Learning Objectives:**
* Use the Neo4j Graph Data Science (GDS) library to run advanced algorithms.
* Identify ecologically important nodes using centrality algorithms.
* Discover functional groups of organisms using community detection algorithms.

**Content:**
* **The GDS Library**: A powerful, parallelized library for executing graph algorithms directly within Neo4j.
* **Pathfinding**: Finding the shortest or most efficient path for nutrient flow.
* **Centrality Algorithms**:
    * **Degree Centrality**: "Who is the most connected?" (Generalists).
    * **Betweenness Centrality**: "Who is the most important bridge between other groups?" (Keystone species).
* **Community Detection**:
    * **Louvain Modularity / Label Propagation**: Algorithms that find clusters of nodes that are more densely connected to each other than to the rest of the graph. These often correspond to functional "guilds" (e.g., a cluster of cellulose decomposers).

**Graph Data Science Workshop:**
* Using your integrated food web graph and the GDS library:
    1.  Run the **PageRank** algorithm to identify the most influential organisms in the food web.
    2.  Run the **Louvain** community detection algorithm to partition the ecosystem into functional guilds.
    3.  Visualize the results in the Neo4j Browser, coloring nodes by their community ID. Interpret what these communities might represent.

---

### **Hour 13-14: Connecting the Graph: Python Drivers & APIs** üêç

**Learning Objectives:**
* Connect to and query a Neo4j database from a Python application.
* Structure your application code to cleanly separate queries from logic.
* Build a simple API function that exposes a complex graph query to other services.

**Content:**
* **The Official Neo4j Driver**: Using the `neo4j` Python library to establish a connection, manage sessions, and execute transactions.
* **Best Practices**:
    * Using parameterized queries to prevent injection attacks.
    * Managing transactions to ensure data integrity.
    * Processing results returned by the driver.
* **Building a Bridge to Foundation Models**: Writing Python functions that encapsulate complex Cypher queries. This creates a simple API that other modules can call without needing to know Cypher. Example: a function `get_organisms_with_pathway(pathway_name)`.

**Application Development Lab:**
* Write a Python script that uses the `neo4j` driver to connect to your database.
* Create a function that takes a nematode species name as an argument.
* The function should query the database to find all the bacteria that the nematode eats and return them as a list.
* This lab demonstrates how to programmatically interact with the graph, forming the basis for more complex applications.

---

### **Hour 15: Capstone: Building and Analyzing an Integrated Soil Knowledge Graph** üèÜ

**Final Challenge:**
You are given a rich dataset for a single soil sample, designed to test your ability to integrate heterogeneous information into a single, powerful knowledge graph.

**The Data Provided:**
1.  **Metagenomics (Module 5)**: A list of MAGs and their annotated KEGG pathways.
2.  **Taxonomy (External DB)**: A file mapping MAGs to taxonomic names and functional guilds (e.g., 'Cellulose Decomposer', 'Bacterivore').
3.  **Metabolomics (Conceptual)**: A list of key chemical compounds detected in the soil sample.
4.  **Known Interactions (Literature)**: A simple list of `(pathway, produces, compound)` and `(pathway, consumes, compound)` interactions.

**Your Mission:**
1.  **Design a Unified Schema**: Create a graph schema diagram that models all these entities and their relationships. It should include nodes like `:MAG`, `:Pathway`, `:Compound`, `:FunctionalGuild` and relationships like `:HAS_PATHWAY`, `:PRODUCES`, `:CONSUMES`, `:IS_MEMBER_OF`.
2.  **Build the Ingestion Pipeline**: Write a single, well-documented Cypher script that uses `LOAD CSV` to build the entire, multi-faceted knowledge graph.
3.  **Perform Hypothesis-Driven Queries**: Write and execute Cypher queries to answer the following questions:
    a.  **Resource Competition**: "Find all compounds that are consumed by more than one metabolic pathway present in the sample. Which guilds compete for these resources?"
    b.  **Syntrophy Detection**: "Is there a potential syntrophic relationship? Find a pair of MAGs where MAG_A produces a compound that is consumed by a pathway present in MAG_B."
    c.  **Trophic-Metabolic Link**: "List all the bacterivore nematodes and, for each, list the metabolic pathways possessed by their potential prey."

**Deliverables:**
* The graph schema diagram.
* The runnable Cypher ingestion script.
* A Jupyter Notebook or Python script containing the analytical queries, their Cypher code, and the results, with clear interpretations.
* A brief report explaining how the graph model enabled the discovery of the syntrophic relationship‚Äîa query that would be exceptionally difficult in a relational model.

**Assessment Criteria:**
* The elegance and correctness of the graph schema.
* The robustness and efficiency of the ingestion script.
* The correctness and complexity of the analytical Cypher queries.
* The depth of insight and clarity of interpretation in the final analysis.
