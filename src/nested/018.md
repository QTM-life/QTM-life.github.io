# **Module 18: Compression Algorithms for Scientific Data**

Implement domain-specific compression for spectral data, DNA sequences, and image stacks. Balance compression ratios with information preservation for model training.

The course objective is to implement intelligent, domain-specific compression strategies that drastically reduce the storage and transmission costs of large-scale soil datasets without compromising their scientific value. Students will master the trade-offs between lossless and lossy compression for diverse data types‚Äîincluding spectral libraries, DNA sequences, and 3D image stacks‚Äîand learn to validate that information critical for model training is preserved.

This module directly confronts the economic and logistical realities of the petabyte-scale "Global Soil Data Commons" envisioned in the **Manifesto**. It builds upon the data lake architecture from Module 15 and the cloud compute infrastructure from Module 14, making that vision financially and technically feasible. Effective compression is the enabling technology that reduces storage costs, accelerates data transfer to training clusters, and makes the entire MLOps lifecycle for foundation models more efficient.

---

### **Hour 1-2: The Data Deluge: Economics and Principles of Compression** üí∞

**Learning Objectives:**
* Calculate the financial and performance costs associated with storing and transferring uncompressed petabyte-scale data.
* Differentiate fundamentally between lossless and lossy compression.
* Define the core trade-off between compression ratio, computational speed, and information preservation.

**Content:**
* **The Cost of a Petabyte**: We'll start with a practical calculation: using a major cloud provider's pricing, what is the annual cost to store 1 PB of soil data? What is the cost to transfer it out for analysis? This provides the economic motivation for the entire module.
* **The Two Philosophies of Compression**:
    * **Lossless**: The data is perfectly preserved. The original can be reconstructed bit-for-bit (e.g., GZIP, ZSTD, PNG). This is the safest option.
    * **Lossy**: Information is permanently discarded to achieve much higher compression ratios (e.g., JPEG, MP3). The key question: can we discard information that is irrelevant to our scientific models?
* **The Compression Trilemma**: It's a three-way trade-off. You can pick any two:
    * **High Ratio** (small file size)
    * **High Speed** (fast compression/decompression)
    * **Perfect Fidelity** (lossless)

**Hands-on Lab:**
* Take a 100MB CSV file of soil data.
* Write a Python script to compress it using three different lossless algorithms: `gzip`, `bz2`, and `zstandard`.
* Create a table comparing their performance on three metrics: **compression ratio**, **compression time**, and **decompression time**. This provides a tangible understanding of the trade-offs.

---

### **Hour 3-4: Compressing Tabular Data with Columnar Formats** üìä

**Learning Objectives:**
* Understand how columnar storage formats like Apache Parquet inherently enable better compression.
* Apply different compression codecs within Parquet.
* Analyze the impact of data sorting on compression efficiency.

**Content:**
* **Why Row-Based is Inefficient**: Compressing a CSV file with GZIP mixes different data types (strings, integers, floats), limiting the compressor's effectiveness.
* **The Columnar Advantage**: Formats like Parquet and ORC store data by column. This groups similar data types together, allowing for specialized encoding:
    * **Dictionary Encoding**: For low-cardinality string columns (e.g., soil texture class).
    * **Run-Length Encoding (RLE)**: For columns with repeated values.
    * **Delta Encoding**: For sorted or sequential data (e.g., timestamps).
* **The Final Squeeze**: After encoding, a general-purpose codec (like **Snappy**, **GZIP**, or **ZSTD**) is applied to each column.

**Practical Exercise:**
* Take the large, clean tabular dataset from the Module 16 capstone.
* Save it in three formats: uncompressed CSV, GZIP-compressed CSV, and Parquet with Zstandard compression.
* Compare the file sizes on disk.
* Time how long it takes to read each file into a Pandas DataFrame and calculate the mean of a specific column. Observe how Parquet is both smaller and often faster to query.

---

### **Hour 5-6: Domain-Specific Compression for DNA Sequences** üß¨

**Learning Objectives:**
* Understand why general-purpose compressors are suboptimal for genomic data.
* Differentiate between reference-based and reference-free genomic compression.
* Use specialized tools to efficiently compress FASTQ files.

**Content:**
* **The Structure of FASTQ**: These files contain two related but different data types: the DNA sequence (A, C, G, T) and the Phred quality scores (ASCII characters). A good compressor treats them differently.
* **Reference-Based Compression (e.g., CRAM)**: The ultimate in compression. If you have a high-quality reference genome, you only need to store the *differences*. This is incredibly powerful but often not applicable to soil metagenomics where most organisms are unknown.
* **Reference-Free FASTQ Compressors**: We will focus on tools like **Spring** or **fqzcomp** that are designed for metagenomic data. They build custom models for the DNA and quality score streams to achieve high compression ratios without needing a reference.

**Hands-on Lab:**
* Take a large FASTQ file from the Module 5 exercises.
* Compress it using `gzip`. Note the file size.
* Install and use a state-of-the-art FASTQ compressor like Spring.
* Compare the resulting file size to the gzipped version. The domain-specific tool will produce a significantly smaller file, demonstrating its superiority.

---

### **Hour 7-8: Lossy Compression for Soil Spectral Data** üìâ

**Learning Objectives:**
* Implement dimensionality reduction as a form of lossy compression for high-dimensional spectra.
* Use numerical quantization to reduce the precision of spectral data.
* Validate that the lossy compression has not significantly harmed downstream model performance.

**Content:**
* **The Case for Lossy**: A soil spectrum often contains ~2000 floating-point numbers. Much of this is noise or redundant information. We can likely discard some of it without affecting our ability to predict soil properties.
* **Compression via Dimensionality Reduction**:
    * Using **Principal Component Analysis (PCA)** to transform the 2000-point spectrum into a much smaller set of (e.g., 50) principal component scores. The compressed data *is* this small set of scores.
* **Compression via Quantization**:
    * Reducing the precision of the numbers from 32-bit floats to 16-bit floats or even 8-bit integers.
* **The Validation Pipeline**: The most critical step. To justify using lossy compression, you *must* prove it doesn't hurt.
    1.  Train a model (e.g., PLS or Ridge regression) on the original, full-fidelity data.
    2.  Compress and then decompress the data.
    3.  Train the *same model* on the reconstructed data.
    4.  Compare the cross-validated Root Mean Squared Error (RMSE) of the two models. If the difference is negligible, the compression is acceptable.

**Technical Workshop:**
* Using the soil spectral library from Module 4:
    1.  Build a scikit-learn pipeline that trains a Ridge regression model to predict soil carbon. Record its cross-validated RMSE.
    2.  Build a second pipeline that first applies PCA (retaining 99.9% of variance), then trains the same Ridge model. Record its RMSE.
    3.  Compare the number of features (original vs. PCA components) and the model RMSEs to quantify the compression ratio and the information loss.

---

### **Hour 9-10: Compressing 3D Micro-CT Image Stacks** üß±

**Learning Objectives:**
* Understand the challenges of compressing large 3D volumetric datasets.
* Differentiate between image codecs and their suitability for scientific data.
* Use modern, chunk-based storage formats like Zarr for efficient compression and access.

**Content:**
* **The Data Cube**: A micro-CT scan of a soil core is a stack of 2D images, forming a 3D data cube that can be gigabytes or terabytes in size.
* **Why JPEG is a Bad Idea**: Standard JPEG creates "blocky" artifacts that corrupt the fine-scale structural information (like pore connectivity) that is scientifically important.
* **Better Alternatives**:
    * **Lossless**: PNG or lossless TIFF are safe but offer moderate compression.
    * **Lossy (but good)**: JPEG 2000 uses wavelet compression, which avoids blocky artifacts and is much better for scientific images.
* **The Cloud-Native Approach: Zarr**: A modern format for chunked, compressed, N-dimensional arrays. It's not just a file format; it's a storage protocol. It splits the array into small chunks and compresses each one individually using fast, modern codecs like **Blosc** or **Zstandard**.

**Practical Exercise:**
* Take a sample 3D micro-CT dataset (a folder of TIFF images).
* Write a Python script using the `zarr` and `imageio` libraries to convert this stack of images into a single, compressed Zarr array stored on disk.
* Compare the total size of the original TIFFs to the size of the Zarr directory.
* Use a viewer like napari to visually inspect the original and the Zarr-loaded data to confirm that no significant information was lost.

---

### **Hour 11-12: Architecture, Cloud Formats, and I/O Performance** ‚òÅÔ∏è

**Learning Objectives:**
* Analyze the trade-off between CPU cost (for compression/decompression) and I/O cost (storage/network).
* Understand how cloud-optimized formats enable partial, remote data access.
* Integrate compression into the Kubernetes training architecture from Module 14.

**Content:**
* **The Compute vs. I/O Tradeoff**: Decompressing data takes CPU time. Is it faster to read a large, uncompressed file from a fast disk, or to read a small, compressed file and spend time decompressing it? The answer depends on the speed of your storage vs. your CPU.
* **Cloud-Optimized Formats (COGs & Zarr)**: Their power is not just compression, but **chunking**. Because the data is stored in independent chunks, you can read a small piece of a massive file from cloud object storage without having to download the entire file first.
* **Impact on K8s Architecture**:
    * **Faster Pod Start-up**: Training pods can start faster because they only need to download a fraction of the data.
    * **Reduced Network Congestion**: Less data is moving from the data lake to the compute cluster.
    * **Cost Savings**: Reduced egress fees and smaller persistent volume claims.

**Performance Lab:**
* Using the compressed Zarr array from the previous lab, store it in a cloud-like object store (e.g., a local MinIO server).
* Write a Python script that remotely accesses this Zarr array.
* Time two operations:
    1.  Reading the metadata and the shape of the entire array (should be very fast).
    2.  Reading a small 10x10x10 voxel sub-cube from the center of the array.
* Compare this to the time it would take to download the entire original dataset.

---

### **Hour 13-14: Developing a Holistic Compression Strategy** üó∫Ô∏è

**Learning Objectives:**
* Synthesize the course concepts into a decision-making framework.
* Create a formal "Compression Strategy" for a complex, multimodal dataset.
* Balance technical possibilities with project requirements (e.g., budget, performance needs, archival policy).

**Content:**
* **The Compression Decision Tree**: A framework to guide choices:
    1.  **What is the data's purpose?** (Active analysis vs. Long-term cold storage).
    2.  **Is any information loss tolerable?** (Lossless vs. Lossy).
    3.  **If lossy, how is information loss measured?** (Visual quality? Downstream model performance? Statistical similarity?).
    4.  **What is the access pattern?** (Full dataset scans vs. small random reads?). This determines the choice of format (e.g., Parquet vs. Zarr).
    5.  **What are the computational constraints?** (Is decompression speed critical?).
* **Workshop**: As a class, we will design a comprehensive compression strategy for the entire "Global Soil Data Commons," creating specific recommendations for each major data type we have studied.

**Strategy Exercise:**
* Students are given two scenarios:
    1.  A real-time sensor network where data must be queried with low latency for immediate alerts.
    2.  A national soil archive program focused on preserving historical data for 100+ years with maximum fidelity.
* For each scenario, students must write a short document outlining their recommended compression strategy, justifying their choice of algorithms, formats, and lossiness based on the specific requirements.

---

### **Hour 15: Capstone: The Information-Preserving Archival Pipeline** üèÜ

**Final Challenge:**
You are tasked with creating an automated, version-controlled pipeline to compress a complete, multimodal soil dataset for cost-effective archival in the project's data lake. The key constraint is that the scientific utility of the data for a specific, defined modeling task must not be compromised.

**The Input Dataset:**
* A set of high-dimensional MIR spectra.
* A folder of TIFF images representing a 3D micro-CT scan of a soil aggregate.
* A FASTQ file with metagenomic reads from the same sample.
* A simple PLS regression model (in a pickle file) that predicts soil carbon from the MIR spectra.

**Your Mission:**
1.  **Design the Strategy**: For each of the three data types, choose an appropriate compression algorithm and format. You are permitted to use lossy compression for the spectra and CT scan but must use lossless for the FASTQ file.
2.  **Build the Pipeline**: Using **DVC**, create a `dvc.yaml` that defines the compression and validation workflow. The pipeline should take the raw data as input and produce the compressed artifacts.
3.  **Validate Information Preservation**: The pipeline *must* include a validation stage for the spectral data. This stage will:
    a.  Decompress the lossily compressed spectra.
    b.  Use the provided PLS model to make predictions on both the original spectra and the reconstructed spectra.
    c.  Calculate the Mean Absolute Error (MAE) between the two sets of predictions.
    d.  The pipeline should **fail** if the MAE is above a predefined tolerance (e.g., 0.1%), proving that your compression was too aggressive.
4.  **Quantify the Results**: The pipeline should output a final `report.md` that includes:
    * The original and compressed size for each data type.
    * The overall compression ratio.
    * The result of the validation step (the prediction MAE).

**Deliverables:**
* A Git repository containing the complete, runnable DVC pipeline.
* The `report.md` file generated by a successful pipeline run.
* A short reflection on the trade-offs you made (e.g., "I chose a higher level of quantization for the CT scan to save space, accepting some visual noise, but used a very gentle PCA for the spectra to ensure the model performance was maintained.").

**Assessment Criteria:**
* The appropriateness and justification of the chosen compression strategies.
* The correctness and robustness of the DVC pipeline implementation.
* The successful implementation of the automated validation step, demonstrating a clear understanding of the information preservation principle.
* The clarity and insight of the final report and reflection.